Шипиль Анна Александровна БПИ-203
 Отчет по домашней работе 2.
 
1. Описание задания
Начальное условие задачи
 Вариант 12. Животные
- Базовые альтернативы: Рыбы (место проживания – перечислимый тип: река, море, озеро…), Птицы (отношение к перелету: перелетные, остающиеся на зимовку – булевская величина),
Звери (хищники, травоядные, насекомоядные… – перечислимый тип)
- Общие для всех альтернатив переменные: Название – строка символов, Вес в граммах (целое)
- Общая для всех альтернатив функция: Частное от деления суммы кодов названия животного на вес (действительное число)
Обработка данных в контейнере
 Вариант 8. Упорядочить элементы контейнера по возрастанию, используя сортировку с помощью разделения (Quick Sort).
В качестве ключей для сортировки и других действий используются результаты функции, общей для всех альтернатив.

2. Структура изучаемой вычислительной системы
Схема программы
animal.h->function.asm
animal.h->main.c
input.c->main.c
output.c->main.c
function.asm->main.c
QuickSort->main.c

Память
Типы
название типа:                                              |  размер:
____________________________________________________________________________________
char                                                        |  1 байт
char*                                                       |  255 байт
int                                                         |  4 байта
double                                                      |  8 байт
void*                                                       |  8 байт
void* (animal)                                              |  263 байт (4 + 4 + 255)
void* (container)                                           |  2 630 000 байт (263 * 10 000)

3. Основные характеристики программы:
 - число интерфейсных модулей (заголовочных файлов): 2 - animal.h - основной интерфейс, QSort - модуль с сортировкой
 - и модулей реализации (фалов с определением программных объектов): 1 - сама программа, main.c
 - общий размер исходных текстов программы: 12 КБ (394 строки)
 - время выполнения программы для различных тестовых наборов данных (test0, test1 и manualTestn (n = 1..5) - ручные тесты, остальные сгенирированы программой подправленной для ввода этого задания Generator из предыдущих заданий):
 test1: 0.001 секунд - 0 объектов
 test7: 0.001 секунд - 2 объекта
 manualTest2: 0.001 секунд - 3 объекта
 manualTest3: 0.001 секунд - 5 объектов
 manualTest4: 0.001 секунд - 5 объектов
 manualTest5: 0.001 секунд - 6 объектов
 manualTest1: 0.001 секунд - 4 объекта
 test0: 0.001 секунд - 9 объектов
 test3: 0.001 секунд - 25 объектов
 test4: 0.001 секунд - 50 объектов
 test6: 0.001 секунд - 52 объекта
 test5: 0.003 секунд - 179 объектов
 test8: 0.009 секунд - 500 объектов
 test9: 0.017 секунд - 1000 объектов
 test10: 0.041 секунд - 2500 объектов
 test11: 0.079 секунд - 5000 объектов
 test2: 0.152 секунд - 10000 объектов

4. Сравнение
Это решение работает быстрее, чем аналогиченые на С, С++ и python. Это можно объяснить тем, что в данном решении используется более низкоуровневый код.
Но размер исходного кода стал больше, времени на написание программы ушло намного больше (это минусы данного решения).
Прихожу к выводу, что это решение сложнее писать, для такой задачи, которую можно решить на С/С++, это кажется неразумным.
Тем не менее, в некоторых ситуациях нужно написать что-то низкоуровневое или очень быстрое. Для таких ситуаций nasm обладает рядом преимуществ.

