Шипиль Анна Александровна БПИ-203
 Отчет по домашней работе 2.
 
1. Описание задания
Начальное условие задачи
 Вариант 12. Животные
- Базовые альтернативы: Рыбы (место проживания – перечислимый тип: река, море, озеро…), Птицы (отношение к перелету: перелетные, остающиеся на зимовку – булевская величина),
Звери (хищники, травоядные, насекомоядные… – перечислимый тип)
- Общие для всех альтернатив переменные: Название – строка символов, Вес в граммах (целое)
- Общая для всех альтернатив функция: Частное от деления суммы кодов названия животного на вес (действительное число)
Обработка данных в контейнере
 Вариант 8. Упорядочить элементы контейнера по возрастанию, используя сортировку с помощью разделения (Quick Sort).
В качестве ключей для сортировки и других действий используются результаты функции, общей для всех альтернатив.

2. Структура изучаемой вычислительной системы
Типы
название типа:                                              |  размер:
____________________________________________________________________________________
char                                                        |  1 байт
int                                                         |  4 байта
double                                                      |  8 байт
void*                                                       |  8 байт
int                                                         |  4 байта
int                                                         |  4 байта
enum EatingType (predator, herbivore, insectivorous)        |  4[0] байта
class Beast (int, int, enum EatingType)                     |  12 байт (4[0] + 4[0] + 4[0])
enum PlaceOfLiving (river, sea, lake)                       |  4[0] байта
class Fish (int, int, enum EatingType)                      |  12 байт (4[0] + 4[0] + 4[0])
class Bird (int, int, bool)                                 |  12 байт (4[0] + 4[0] + 1[0] (размер bool может быть больше, зависит от реализации) + 3 (выравнивание)) 
std::vector<IAnimal*>(n)                                    |  около 12 * n + 24 байт (12 * n + sizeof(vector) (это обычно 3*sizeof(void*), т.е. 24) + O(n) байт)


3. Основные характеристики программы:
 - число интерфейсных модулей (заголовочных файлов): 4 - Animal.h - основной интерфейс, Bird.h, Beast.h и Fish.h - заголовочные файлы реализующие интерфейс из Animal.h в соответствующих классах
 - и модулей реализации (фалов с определением программных объектов): 2 - сама программа и генератор тестов
 - общий размер исходных текстов программы: 9 КБ (221 строка), генератора тестов: 4 КБ (92 строки)
 - полученный размер исполняемого кода (если он формируется): основной программы: 132 КБ, генератора тестов: 42 КБ
 - время выполнения программы для различных тестовых наборов данных (test0, test1 и manualTestn (n = 1..5) - ручные тесты, остальные сгенирированы программой Generator):
 test1: 0.001 секунд - 0 объектов
 test7: 0.001 секунд - 2 объекта
 manualTest2: 0.001 секунд - 3 объекта
 manualTest1: 0.002 секунд - 4 объекта
 manualTest3: 0.002 секунд - 5 объектов
 manualTest4: 0.002 секунд - 5 объектов
 manualTest5: 0.002 секунд - 6 объектов
 test0: 0.002 секунд - 9 объектов
 test3: 0.006 секунд - 25 объектов
 test4: 0.012 секунд - 50 объектов
 test6: 0.012 секунд - 52 объекта
 test5: 0.022 секунд - 179 объектов
 test8: 0.034 секунд - 500 объектов
 test9: 0.061 секунд - 1000 объектов
 test10: 0.130 секунд - 2500 объектов
 test11: 0.218 секунд - 5000 объектов
 test2: 0.441 секунд - 10000 объектов
4. Сравнение
Решение домашнего задания 1 выполняло ту же задачу быстрее (почти в 2 раза). Делаю вывод, что причина в использовании библиотек С в прошлой работе, в этом задании я использовала библиотеки С++. Размер исполняемого кода программы тоже увеличился.
Плюсы у второго решения тоже есть. Получилось немного меньше строк кода, и, на мой взгляд, некоторые вещи проще писать и использовать в последствии: я переопределила оператор сравнения для животных, поэтому для сравнений в сортировке (а также при добавлении доп функционала) больше не нужно задумываться каждый раз, как сравнить объекты. Тем не менее, вместо оператора сравнения в прошлой работе можно было написать отдельную функцию для сравнения. Использование строк стандартной библиотеки С++ позволяет легче их считывать, копировать, сравнивать с помощью операторов сравнения, а так же использовать стандартные функции (которые в данном решении не пригодились). В первом же решении часто приходилось использовать функции для работы со строками (вместо операторов): и для копирования, и для сравнения. Вектор стандартной библиотеки С++ позволяет менять размер в ходе выполнения программы, добавлять элементы.
Таким образом, прихожу к выводу, что второе решение проще (а значит быстрее, что в промышленной разработке бывает важно) писать и рефакторить (добавлять новый функционал). Первое же решение быстрее работает и занимает меньше памяти.
